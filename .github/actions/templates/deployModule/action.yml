name: 'Deploy module'
description: 'Deploy module'

inputs:
  moduleName:
    description: 'The name of the module to deploy'
    required: true
  templateFilePath:
    description: 'The path to the template file to use for deployment'
    required: true
  parameterFilePath:
    description: 'The path to the parameter file to use for deployment'
    required: true
  location:
    description: 'The location to use for deployment'
    required: true
  resourceGroupName:
    description: 'The resource group to deploy to'
    required: false
  subscriptionId:
    description: 'The subscriptionId to deploy to'
    required: false
  managementGroupId:
    description: 'The managementGroupId to deploy to'
    required: false
  removeDeployment:
    description: 'Set "true" to set module up for removal'
    default: 'true'
    required: false
  relativePathOfRemovalScript:
    description: 'The relative path from root to the script that removes the service'
    required: false
    default: 'utilities/pipelines/resourceRemoval/Remove-DeployedModule.ps1'

runs:
  using: 'composite'
  steps:
    - name: 'Setup agent'
      shell: pwsh
      run: |
        # Load used functions
        . (Join-Path $env:GITHUB_WORKSPACE 'utilities' 'pipelines' 'sharedScripts' 'Set-EnvironmentOnAgent.ps1')

        # Set agent up
        Set-EnvironmentOnAgent

    - name: Azure Login
      uses: Azure/login@v1
      with:
        creds: ${{ env.AZURE_CREDENTIALS }}
        enable-AzPSSession: true

    - name: 'Replace Parameter File Tokens [${{ inputs.parameterFilePath }}] '
      shell: pwsh
      run: |
        # Load used functions
        . (Join-Path $env:GITHUB_WORKSPACE 'utilities' 'pipelines' 'tokensReplacement' 'Convert-TokensInParameterFile.ps1')

        # Load Settings File
        $Settings = Get-Content -Path "settings.json" | ConvertFrom-Json
        # Initialize Default Parameter File Tokens
        $DefaultParameterFileTokens = @(
            @{ Name = 'resourceGroupName'; Value = '${{ inputs.resourceGroupName }}' }
            @{ Name = 'subscriptionId'; Value = '${{ inputs.subscriptionId }}' }
            @{ Name = 'managementGroupId'; Value = '${{ inputs.managementGroupId }}' }
            @{ Name = "tenantId"; Value = '${{ env.ARM_TENANT_ID }}' }
            @{ Name = "deploymentSpId"; Value = '${{ env.DEPLOYMENT_SP_ID }}' }
            @{ Name = "platformKeyVault"; Value = '${{ env.PLATFORM_KEYVAULT }}' }
        ) | ForEach-Object { [PSCustomObject]$PSItem }

        # Construct Token Function Input
        $ConvertTokensInputs = @{
            ParameterFilePath                 = '${{ inputs.parameterFilePath }}'
            DefaultParameterFileTokens        = $DefaultParameterFileTokens
            LocalCustomParameterFileTokens    = $Settings.parameterFileTokens.localTokens.tokens
            TokenPrefix                       = $Settings.parameterFileTokens.tokenPrefix
            TokenSuffix                       = $Settings.parameterFileTokens.tokenSuffix
        }
        # Add Remote Custom Parameter File Tokens
        if ('${{ env.PLATFORM_KEYVAULT }}' -and '${{ inputs.subscriptionId }}') {
            $ConvertTokensInputs += @{
                TokensKeyVaultName                 = '${{ env.PLATFORM_KEYVAULT }}'
                TokensKeyVaultSubscriptionId       = '${{ inputs.subscriptionId }}'
                TokensKeyVaultSecretNamePrefix     = $Settings.parameterFileTokens.remoteTokens.keyVaultSecretNamePrefix
            }
        }
        # Invoke Token Replacement Functionality
        $null = Convert-TokensInParameterFile @ConvertTokensInputs -Verbose

    - name: 'Deploy [${{ inputs.templateFilePath }}] with parameters [${{ inputs.parameterFilePath }}]'
      shell: pwsh
      run: |
        # Load used functions
        . (Join-Path $env:GITHUB_WORKSPACE 'utilities' 'pipelines' 'resourceDeployment' 'New-ModuleDeployment.ps1')

        $functionInput = @{
          moduleName         = '${{ inputs.moduleName }}'
          templateFilePath   = '${{ inputs.templateFilePath }}'
          parameterFilePath  = '${{ inputs.parameterFilePath }}'
          location           = '${{ inputs.location }}'
          resourceGroupName  = '${{ inputs.resourceGroupName }}'
          subscriptionId     = '${{ inputs.subscriptionId }}'
          managementGroupId  = '${{ inputs.managementGroupId }}'
          removeDeployment   = [System.Convert]::ToBoolean('${{ inputs.removeDeployment }}')
        }

        Write-Verbose "Invoke task with" -Verbose
        Write-Verbose ($functionInput | ConvertTo-Json | Out-String) -Verbose

        # Invoke deployment
        try {
          $res = New-ModuleDeployment @functionInput -Verbose
          $deploymentSuccessful = $true
        } catch {
          $res = $_.Exception.Message
          $deploymentSuccessful = $false
        }

        Write-Output "::set-env name=deploymentAttempted::$true"

        if(-not $deploymentSuccessful) {
          throw $res
        }

    - name: 'Remove [${{ inputs.templateFilePath }}] from parameters [${{ inputs.parameterFilePath }}]'
      shell: pwsh
      run: |
        Write-Verbose (Get-Childitem env:* | Out-String) -Verbose

        if('${{ inputs.removeDeployment }}' -eq 'true' -and $deploymentAttempted -eq $true) {
          # Load used functions
          $functionPath = Join-Path $env:GITHUB_WORKSPACE '${{ inputs.relativePathOfRemovalScript }}'
          . $functionPath

          $functionInput = @{
              moduleName        = '${{ inputs.moduleName }}'
              resourceGroupName = '${{ inputs.resourceGroupName }}'
              verbose           = $true
          }

          Write-Verbose 'Invoke task with' -Verbose
          Write-Verbose ($functionInput | ConvertTo-Json | Out-String) -Verbose

          Invoke-Expression ('{0} @functionInput' -f (Split-Path $functionPath -LeafBase))
        }
